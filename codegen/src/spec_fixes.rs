//! OpenAPI spec fixes for issues with schemars-generated schemas

use anyhow::Result;
use serde_json::{json, Value};

/// Apply all spec fixes
pub fn fix_spec(spec: &mut Value) -> Result<()> {
    let schemas = spec
        .get_mut("components")
        .and_then(|c| c.get_mut("schemas"))
        .ok_or_else(|| anyhow::anyhow!("No components.schemas in spec"))?;

    // Fix GlobalContractIdentifierView: anyOf -> oneOf
    if let Some(schema) = schemas.get_mut("GlobalContractIdentifierView") {
        if let Some(any_of) = schema.get("anyOf").cloned() {
            schema.as_object_mut().unwrap().remove("anyOf");
            schema
                .as_object_mut()
                .unwrap()
                .insert("oneOf".to_string(), any_of);
            println!("  Fixed GlobalContractIdentifierView: anyOf -> oneOf");
        }
    }

    // Fix flattened optional schemas (anyOf/oneOf + properties at same level)
    fix_flattened_schemas(schemas)?;

    // Fix nested allOf containing oneOf patterns
    fix_nested_all_of_one_of(schemas)?;

    Ok(())
}

/// Fix schemas that have anyOf/oneOf + properties at the same level.
///
/// This pattern is generated by schemars when a Rust struct has:
/// - `#[serde(flatten)]` on an `Option<EnumType>` or enum field
/// - Other regular fields
///
/// The schemars output incorrectly merges anyOf/oneOf with properties
/// at the same level, which doesn't properly express the valid JSON structures.
fn fix_flattened_schemas(schemas: &mut Value) -> Result<()> {
    let schemas_obj = schemas.as_object_mut().unwrap();
    let schema_names: Vec<String> = schemas_obj.keys().cloned().collect();

    for name in schema_names {
        let schema = schemas_obj.get_mut(&name).unwrap();

        if !schema.is_object() {
            continue;
        }

        let has_properties = schema.get("properties").is_some();
        if !has_properties {
            continue;
        }

        // Determine which keyword is used (anyOf or oneOf)
        let variant_key = if schema.get("anyOf").is_some() {
            "anyOf"
        } else if schema.get("oneOf").is_some() {
            "oneOf"
        } else {
            continue;
        };

        let variants = schema.get(variant_key).unwrap().as_array().unwrap().clone();
        let properties = schema.get("properties").cloned().unwrap();
        let required = schema.get("required").cloned().unwrap_or(json!([]));

        // Check if all variants are $ref (indicating flattened Option<Enum>)
        let all_refs = variants.iter().all(|v| v.get("$ref").is_some());

        // Build base properties object
        let mut base_props = json!({
            "type": "object",
            "properties": properties
        });
        if required != json!([]) {
            base_props["required"] = required.clone();
        }

        let mut new_variants = Vec::new();

        // For anyOf with all $refs, add empty variant for None case
        if variant_key == "anyOf" && all_refs {
            println!("  Fixing flattened optional schema (anyOf): {}", name);

            let mut empty_variant = json!({
                "type": "object",
                "properties": properties.clone(),
                "additionalProperties": false
            });
            if required != json!([]) {
                empty_variant["required"] = required.clone();
            }
            new_variants.push(empty_variant);

            // Combine each variant with base properties via allOf
            for variant in &variants {
                new_variants.push(json!({
                    "allOf": [variant, base_props]
                }));
            }

            // Replace the schema
            let schema_obj = schema.as_object_mut().unwrap();
            schema_obj.clear();
            schema_obj.insert("anyOf".to_string(), json!(new_variants));
        }
        // For oneOf, merge base properties into each variant
        else if variant_key == "oneOf" {
            println!("  Fixing flattened enum schema (oneOf): {}", name);

            for variant in &variants {
                if variant.get("$ref").is_some() {
                    // Reference type - combine via allOf
                    new_variants.push(json!({
                        "allOf": [variant, base_props]
                    }));
                } else if variant.get("properties").is_some() {
                    // Inline object - merge properties
                    let mut merged = variant.clone();
                    let merged_obj = merged.as_object_mut().unwrap();

                    // Merge properties
                    let variant_props = variant.get("properties").unwrap().as_object().unwrap();
                    let base_props_obj = properties.as_object().unwrap();
                    let mut merged_props = variant_props.clone();
                    for (k, v) in base_props_obj {
                        merged_props.insert(k.clone(), v.clone());
                    }
                    merged_obj.insert("properties".to_string(), json!(merged_props));

                    // Merge required
                    let variant_required: Vec<String> = variant
                        .get("required")
                        .and_then(|r| r.as_array())
                        .map(|arr| {
                            arr.iter()
                                .filter_map(|v| v.as_str().map(String::from))
                                .collect()
                        })
                        .unwrap_or_default();
                    let base_required: Vec<String> = required
                        .as_array()
                        .map(|arr| {
                            arr.iter()
                                .filter_map(|v| v.as_str().map(String::from))
                                .collect()
                        })
                        .unwrap_or_default();

                    let mut all_required: Vec<String> = variant_required;
                    for r in base_required {
                        if !all_required.contains(&r) {
                            all_required.push(r);
                        }
                    }
                    if !all_required.is_empty() {
                        merged_obj.insert("required".to_string(), json!(all_required));
                    }

                    new_variants.push(merged);
                } else {
                    new_variants.push(variant.clone());
                }
            }

            // Replace the schema
            let schema_obj = schema.as_object_mut().unwrap();
            schema_obj.clear();
            schema_obj.insert("oneOf".to_string(), json!(new_variants));
        }
    }

    Ok(())
}

/// Fix nested allOf containing multiple oneOf patterns
/// This distributes them into a single oneOf with all combinations
fn fix_nested_all_of_one_of(schemas: &mut Value) -> Result<()> {
    fn fix_recursive(value: &mut Value) {
        match value {
            Value::Object(obj) => {
                // Check if this object has allOf with multiple oneOf
                if let Some(all_of) = obj.get("allOf").cloned() {
                    if let Some(all_of_arr) = all_of.as_array() {
                        let one_of_count = all_of_arr
                            .iter()
                            .filter(|item| item.get("oneOf").is_some())
                            .count();

                        if one_of_count >= 2 {
                            // Reconstruct: distribute allOf over oneOf
                            let mut one_of_lists: Vec<Vec<Value>> = Vec::new();

                            for item in all_of_arr {
                                if let Some(one_of) = item.get("oneOf").and_then(|o| o.as_array()) {
                                    one_of_lists.push(one_of.clone());
                                } else {
                                    one_of_lists.push(vec![item.clone()]);
                                }
                            }

                            // Generate all combinations
                            let combinations = cartesian_product(&one_of_lists);
                            let new_one_of: Vec<Value> = combinations
                                .into_iter()
                                .map(|combo| json!({"allOf": combo}))
                                .collect();

                            obj.remove("allOf");
                            obj.insert("oneOf".to_string(), json!(new_one_of));
                            println!("  Fixed allOf with multiple oneOf");
                        }
                    }
                }

                // Recurse into all values
                for (_, v) in obj.iter_mut() {
                    fix_recursive(v);
                }
            }
            Value::Array(arr) => {
                for item in arr.iter_mut() {
                    fix_recursive(item);
                }
            }
            _ => {}
        }
    }

    fix_recursive(schemas);
    Ok(())
}

/// Compute cartesian product of multiple vectors
fn cartesian_product(lists: &[Vec<Value>]) -> Vec<Vec<Value>> {
    if lists.is_empty() {
        return vec![vec![]];
    }

    let first = &lists[0];
    let rest = cartesian_product(&lists[1..]);

    let mut result = Vec::new();
    for item in first {
        for rest_combo in &rest {
            let mut combo = vec![item.clone()];
            combo.extend(rest_combo.clone());
            result.push(combo);
        }
    }

    result
}
