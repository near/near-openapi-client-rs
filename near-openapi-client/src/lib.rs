//!# near-openapi-client

//!

//!Progenitor-generated client of NEAR JSON RPC API

//!

//!Consists of two crates:

//! - near-openapi-client - client to connect to the API, generated by progenitor

//! - near-openapi-types - types used by client

//!

//!### Usage example:

//!

//!Add near-openapi-client to your project dependencies:

//!```

//!cargo add near-openapi-client

//!```

//!

//!Use the client to get latest block info:

//!```rust

//!use near_openapi_client as client;

//!

//!// Setup client

//!const NEAR_RPC_URL_REMOTE: &str = "https://archival-rpc.mainnet.near.org";

//!let client_remote = client::Client::new(NEAR_RPC_URL_LOCAL);

//!

//!// Construct request

//!let payload_block_final = client::types::JsonRpcRequestForBlock {

//!    id: String::from("dontcare"),

//!    jsonrpc: String::from("2.0"),

//!    method: client::types::JsonRpcRequestForBlockMethod::Block,

//!    params: client::types::RpcBlockRequest::Finality(client::types::Finality::Final),

//!};

//!

//!// Make the request, get the response

//!let block_final: client::types::JsonRpcResponseForRpcBlockResponseAndRpcError =

//!    client_local.block(&payload_block_final).await?.into_inner();

//!println!("block_final: {:#?}", block_final);

//!```

//!

//!<details>

//!

//!<summary>Example response</summary>

//!

//!```

//!response for block_final: Variant0 {

//!    id: "dontcare",

//!    jsonrpc: "2.0",

//!    result: RpcBlockResponse {

//!        author: AccountId(

//!            "test.near",

//!        ),

//!        chunks: [

//!            ChunkHeaderView {

//!                balance_burnt: "0",

//!                bandwidth_requests: Some(

//!                    V1(

//!                        BandwidthRequestsV1 {

//!                            requests: [],

//!                        },

//!                    ),

//!                ),

//!                chunk_hash: CryptoHash(

//!                    "59srn1AQyCxqhXuURBGomupX8tCEj25XXFW15YZDgnM6",

//!                ),

//!                congestion_info: Some(

//!                    CongestionInfoView {

//!                        allowed_shard: 0,

//!                        buffered_receipts_gas: "0",

//!                        delayed_receipts_gas: "0",

//!                        receipt_bytes: 0,

//!                    },

//!                ),

//!                encoded_length: 8,

//!                encoded_merkle_root: CryptoHash(

//!                    "79Bt7ivt9Qhp3c6dJYnueaTyPVweYxZRpQHASRRAiyuy",

//!                ),

//!                gas_limit: 1000000000000000,

//!                gas_used: 0,

//!                height_created: 6,

//!                height_included: 6,

//!                outcome_root: CryptoHash(

//!                    "11111111111111111111111111111111",

//!                ),

//!                outgoing_receipts_root: CryptoHash(

//!                    "H4Rd6SGeEBTbxkitsCdzfu9xL9HtZ2eHoPCQXUeZ6bW4",

//!                ),

//!                prev_block_hash: CryptoHash(

//!                    "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!                ),

//!                prev_state_root: CryptoHash(

//!                    "7t7WeJdAzh9qmKLHfVRboDZupfAjfy9FC3onAN1LRnyp",

//!                ),

//!                rent_paid: "0",

//!                shard_id: ShardId(

//!                    0,

//!                ),

//!                signature: Signature(

//!                    "ed25519:5G8UWLLuVk3WvQTnSHmT7EQoCz521EaaxQ8f5mgNVxJjFW7o9VFfxuG6D5bNfCjmoTVWbc9WrUbXg2L11iGWQw2g",

//!                ),

//!                tx_root: CryptoHash(

//!                    "11111111111111111111111111111111",

//!                ),

//!                validator_proposals: [],

//!                validator_reward: "0",

//!            },

//!        ],

//!        header: BlockHeaderView {

//!            approvals: [

//!                Some(

//!                    Signature(

//!                        "ed25519:4GobVKSiiRfwMBrukNeCLbiUQLAzVprFCSn5jDVqA8zm6oR9H8EudEogsBAedBqJKF8vXhohSC5Kfnsdw2XMXMw6",

//!                    ),

//!                ),

//!            ],

//!            block_body_hash: Some(

//!                CryptoHash(

//!                    "CjDTJC25qznGymgHiUrDwSgaqsme3deDNj3ftPWFfBew",

//!                ),

//!            ),

//!            block_merkle_root: CryptoHash(

//!                "EXTvaXuYTcvEd8KnWjhruX9NYNCTbXJrwfzEJAnELBds",

//!            ),

//!            block_ordinal: Some(

//!                7,

//!            ),

//!            challenges_result: [],

//!            challenges_root: CryptoHash(

//!                "11111111111111111111111111111111",

//!            ),

//!            chunk_endorsements: Some(

//!                [

//!                    [

//!                        1,

//!                    ],

//!                ],

//!            ),

//!            chunk_headers_root: CryptoHash(

//!                "6fPXKHJce8krAwsXfdMgsSgmUd5CgcJBpBFKBhb7QT2j",

//!            ),

//!            chunk_mask: [

//!                true,

//!            ],

//!            chunk_receipts_root: CryptoHash(

//!                "9ETNjrt6MkwTgSVMMbpukfxRshSD1avBUUa4R4NuqwHv",

//!            ),

//!            chunk_tx_root: CryptoHash(

//!                "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",

//!            ),

//!            chunks_included: 1,

//!            epoch_id: CryptoHash(

//!                "11111111111111111111111111111111",

//!            ),

//!            epoch_sync_data_hash: None,

//!            gas_price: "100000000",

//!            hash: CryptoHash(

//!                "8UgWEvtdVcEu6uYBFboZKDoLsWk5DC5tz656fW3BA4ZL",

//!            ),

//!            height: 6,

//!            last_ds_final_block: CryptoHash(

//!                "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!            ),

//!            last_final_block: CryptoHash(

//!                "AMu9bpsii9wjFukjFc5cMaBNCNDvmiz4Z7AmwBAMcDLh",

//!            ),

//!            latest_protocol_version: 78,

//!            next_bp_hash: CryptoHash(

//!                "ChxUrwNyJDYA9PbecbLq1KBvkj2mEW3nvzXHC244X2rT",

//!            ),

//!            next_epoch_id: CryptoHash(

//!                "GsJ8x5msDUv7Zz4LgCxoqzeyWKvNT2sHdFyEdR3vZrCZ",

//!            ),

//!            outcome_root: CryptoHash(

//!                "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",

//!            ),

//!            prev_hash: CryptoHash(

//!                "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!            ),

//!            prev_height: Some(

//!                5,

//!            ),

//!            prev_state_root: CryptoHash(

//!                "9wppbHBR63GhoJWW3ti6qhD5AAEmiNr1DKWQq9kLwrHM",

//!            ),

//!            random_value: CryptoHash(

//!                "6MypYizcvSPkaxgd7cXAgGfHo8TsnmouzLtCHnGASbKe",

//!            ),

//!            rent_paid: "0",

//!            signature: Signature(

//!                "ed25519:3jHUhecrkNYoTDrQ8jARWco8vCNCdrwPewZrv1HQeTE5tQj78fjAYkJbgeFo8wcyi6maTFFYRNdHQ8nrmFa1Pjc",

//!            ),

//!            timestamp: 1750759979825366257,

//!            timestamp_nanosec: "1750759979825366257",

//!            total_supply: "2050000000000000000000000000000000",

//!            validator_proposals: [],

//!            validator_reward: "0",

//!        },

//!    },

//!}

//!```

//!

//!</details>

//!
pub use near_openapi_types as types;
#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[derive(Clone, Debug)]
#[doc = "Client for NEAR Protocol JSON RPC API\n\nVersion: 1.2.2"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.2.2"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
impl Client {
    #[doc = "Calls a view function on a contract and returns the result.\n\nSends a `POST` request to `/EXPERIMENTAL_call_function`\n\n"]
    pub async fn experimental_call_function<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalCallFunction,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcCallFunctionResponseAndRpcCallFunctionError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_call_function",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Returns changes for a given account, contract or contract code for given block height or hash. Consider using changes instead.\n\nSends a `POST` request to `/EXPERIMENTAL_changes`\n\n"]
    pub async fn experimental_changes<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalChanges,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcStateChangesError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_changes",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched. Consider using block_effects instead\n\nSends a `POST` request to `/EXPERIMENTAL_changes_in_block`\n\n"]
    pub async fn experimental_changes_in_block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalChangesInBlock,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcStateChangesError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_changes_in_block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)\n\nSends a `POST` request to `/EXPERIMENTAL_congestion_level`\n\n"]
    pub async fn experimental_congestion_level<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalCongestionLevel,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcCongestionLevelResponseAndRpcChunkError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_congestion_level",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Get initial state and parameters for the genesis block. Consider genesis_config instead.\n\nSends a `POST` request to `/EXPERIMENTAL_genesis_config`\n\n"]
    pub async fn experimental_genesis_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalGenesisConfig,
    ) -> Result<ResponseValue<types::JsonRpcResponseForGenesisConfigAndGenesisConfigError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_genesis_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the proofs for a transaction execution.\n\nSends a `POST` request to `/EXPERIMENTAL_light_client_block_proof`\n\n"]
    pub async fn experimental_light_client_block_proof<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalLightClientBlockProof,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcLightClientProofError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_light_client_block_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the proofs for a transaction execution.\n\nSends a `POST` request to `/EXPERIMENTAL_light_client_proof`\n\n"]    pub async fn experimental_light_client_proof < 'a > (& 'a self , body : & 'a types :: JsonRpcRequestForExperimentalLightClientProof) -> Result < ResponseValue < types :: JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcLightClientProofError > , Error < () > , >{
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_light_client_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer. Consider using maintenance_windows instead.\n\nSends a `POST` request to `/EXPERIMENTAL_maintenance_windows`\n\n"]
    pub async fn experimental_maintenance_windows<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalMaintenanceWindows,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForArrayOfRangeOfUint64AndRpcMaintenanceWindowsError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_maintenance_windows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "A configuration that defines the protocol-level parameters such as gas/storage costs, limits, feature flags, other settings\n\nSends a `POST` request to `/EXPERIMENTAL_protocol_config`\n\n"]
    pub async fn experimental_protocol_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalProtocolConfig,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcProtocolConfigResponseAndRpcProtocolConfigError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_protocol_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Fetches a receipt by its ID (as is, without a status or execution outcome)\n\nSends a `POST` request to `/EXPERIMENTAL_receipt`\n\n"]
    pub async fn experimental_receipt<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalReceipt,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcReceiptResponseAndRpcReceiptError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_receipt",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Contains the split storage information. More info on split storage [here](https://near-nodes.io/archival/split-storage-archival)\n\nSends a `POST` request to `/EXPERIMENTAL_split_storage_info`\n\n"]
    pub async fn experimental_split_storage_info<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalSplitStorageInfo,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcSplitStorageInfoError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_split_storage_info",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries status of a transaction by hash, returning the final transaction result and details of all receipts.\n\nSends a `POST` request to `/EXPERIMENTAL_tx_status`\n\n"]
    pub async fn experimental_tx_status<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalTxStatus,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_tx_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the current epoch validators ordered in the block producer order with repetition. This endpoint is solely used for bridge currently and is not intended for other external use cases.\n\nSends a `POST` request to `/EXPERIMENTAL_validators_ordered`\n\n"]
    pub async fn experimental_validators_ordered<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalValidatorsOrdered,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForArrayOfValidatorStakeViewAndRpcValidatorError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_validators_ordered",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns information about a single access key for given account.\n\nSends a `POST` request to `/EXPERIMENTAL_view_access_key`\n\n"]
    pub async fn experimental_view_access_key<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewAccessKey,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewAccessKeyResponseAndRpcViewAccessKeyError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_access_key",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns all access keys for a given account.\n\nSends a `POST` request to `/EXPERIMENTAL_view_access_key_list`\n\n"]
    pub async fn experimental_view_access_key_list<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewAccessKeyList,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcViewAccessKeyListResponseAndRpcViewAccessKeyListError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_access_key_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns information about an account for given account_id.\n\nSends a `POST` request to `/EXPERIMENTAL_view_account`\n\n"]
    pub async fn experimental_view_account<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewAccount,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewAccountResponseAndRpcViewAccountError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the contract code (Wasm binary) deployed to the account.\n\nSends a `POST` request to `/EXPERIMENTAL_view_code`\n\n"]
    pub async fn experimental_view_code<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewCode,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewCodeResponseAndRpcViewCodeError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_code",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns information about a single gas key for given account.\n\nSends a `POST` request to `/EXPERIMENTAL_view_gas_key`\n\n"]
    pub async fn experimental_view_gas_key<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewGasKey,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewGasKeyResponseAndRpcViewGasKeyError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_gas_key",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns all gas keys for a given account.\n\nSends a `POST` request to `/EXPERIMENTAL_view_gas_key_list`\n\n"]
    pub async fn experimental_view_gas_key_list<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewGasKeyList,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewGasKeyListResponseAndRpcViewGasKeyListError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_gas_key_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the state (key-value pairs) of a contract based on the key prefix.\n\nSends a `POST` request to `/EXPERIMENTAL_view_state`\n\n"]
    pub async fn experimental_view_state<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalViewState,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcViewStateResponseAndRpcViewStateError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_view_state",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns block details for given height or hash\n\nSends a `POST` request to `/block`\n\n"]
    pub async fn block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBlock,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcBlockResponseAndRpcBlockError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched.\n\nSends a `POST` request to `/block_effects`\n\n"]
    pub async fn block_effects<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBlockEffects,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcStateChangesError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "block_effects",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Sends a transaction and immediately returns transaction hash. Consider using send_tx instead.\n\nSends a `POST` request to `/broadcast_tx_async`\n\n"]
    pub async fn broadcast_tx_async<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBroadcastTxAsync,
    ) -> Result<ResponseValue<types::JsonRpcResponseForCryptoHashAndRpcTransactionError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "broadcast_tx_async",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "[Deprecated] Sends a transaction and waits until transaction is fully complete. (Has a 10 second timeout). Consider using send_tx instead.\n\nSends a `POST` request to `/broadcast_tx_commit`\n\n"]
    pub async fn broadcast_tx_commit<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBroadcastTxCommit,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "broadcast_tx_commit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns changes for a given account, contract or contract code for given block height or hash.\n\nSends a `POST` request to `/changes`\n\n"]
    pub async fn changes<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForChanges,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcStateChangesError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "changes",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns details of a specific chunk. You can run a block details query to get a valid chunk hash.\n\nSends a `POST` request to `/chunk`\n\n"]
    pub async fn chunk<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForChunk,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcChunkResponseAndRpcChunkError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "chunk",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries client node configuration\n\nSends a `POST` request to `/client_config`\n\n"]
    pub async fn client_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForClientConfig,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcClientConfigResponseAndRpcClientConfigError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "client_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns gas price for a specific block_height or block_hash. Using [null] will return the most recent block's gas price.\n\nSends a `POST` request to `/gas_price`\n\n"]
    pub async fn gas_price<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForGasPrice,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcGasPriceResponseAndRpcGasPriceError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "gas_price",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get initial state and parameters for the genesis block\n\nSends a `POST` request to `/genesis_config`\n\n"]
    pub async fn genesis_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForGenesisConfig,
    ) -> Result<ResponseValue<types::JsonRpcResponseForGenesisConfigAndGenesisConfigError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "genesis_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the current health status of the RPC node the client connects to.\n\nSends a `POST` request to `/health`\n\n"]
    pub async fn health<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForHealth,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForNullableRpcHealthResponseAndRpcStatusError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "health",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the proofs for a transaction execution.\n\nSends a `POST` request to `/light_client_proof`\n\n"]    pub async fn light_client_proof < 'a > (& 'a self , body : & 'a types :: JsonRpcRequestForLightClientProof) -> Result < ResponseValue < types :: JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcLightClientProofError > , Error < () > , >{
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "light_client_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer.\n\nSends a `POST` request to `/maintenance_windows`\n\n"]
    pub async fn maintenance_windows<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForMaintenanceWindows,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForArrayOfRangeOfUint64AndRpcMaintenanceWindowsError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "maintenance_windows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries the current state of node network connections. This includes information about active peers, transmitted data, known producers, etc.\n\nSends a `POST` request to `/network_info`\n\n"]
    pub async fn network_info<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForNetworkInfo,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcNetworkInfoResponseAndRpcNetworkInfoError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "network_info",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Returns the next light client block.\n\nSends a `POST` request to `/next_light_client_block`\n\n"]
    pub async fn next_light_client_block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForNextLightClientBlock,
    ) -> Result<
        ResponseValue<
            types::JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcLightClientNextBlockError,
        >,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "next_light_client_block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "This module allows you to make generic requests to the network.\n\nThe `RpcQueryRequest` struct takes in a [`BlockReference`](https://docs.rs/near-primitives/0.12.0/near_primitives/types/enum.BlockReference.html) and a [`QueryRequest`](https://docs.rs/near-primitives/0.12.0/near_primitives/views/enum.QueryRequest.html).\n\nThe `BlockReference` enum allows you to specify a block by `Finality`, `BlockId` or `SyncCheckpoint`.\n\nThe `QueryRequest` enum provides multiple variants for performing the following actions:\n - View an account's details\n - View a contract's code\n - View the state of an account\n - View the `AccessKey` of an account\n - View the `AccessKeyList` of an account\n - Call a function in a contract deployed on the network.\n\nSends a `POST` request to `/query`\n\n"]
    pub async fn query<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForQuery,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcQueryResponseAndRpcQueryError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "query",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends transaction. Returns the guaranteed execution status and the results the blockchain can provide at the moment.\n\nSends a `POST` request to `/send_tx`\n\n"]
    pub async fn send_tx<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForSendTx,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "send_tx",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Requests the status of the connected RPC node. This includes information about sync status, nearcore node version, protocol version, the current set of validators, etc.\n\nSends a `POST` request to `/status`\n\n"]
    pub async fn status<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForStatus,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcStatusResponseAndRpcStatusError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries status of a transaction by hash and returns the final transaction result.\n\nSends a `POST` request to `/tx`\n\n"]
    pub async fn tx<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForTx,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcTransactionError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo { operation_id: "tx" };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Queries active validators on the network. Returns details and the state of validation on the blockchain.\n\nSends a `POST` request to `/validators`\n\n"]
    pub async fn validators<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForValidators,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcValidatorResponseAndRpcValidatorError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "validators",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}
#[doc = r" Items consumers will typically use such as the Client."]
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
